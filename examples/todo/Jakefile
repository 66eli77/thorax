var child_process = require("child_process"),
    fs = require("fs"),
    glob = require('glob'),
    growl = require('growl'),
    path = require('path'),
    sys = require("sys"),
    wrench = require('wrench');

// Recursive mkdir
// mkdirsSync(path, [mode=(0777^umask)]) -> pathsCreated
function mkdir(dirname, mode) {
  if (mode === undefined) mode = 0777 ^ process.umask();
  var pathsNotFound = [];
  var fn = dirname;
  while (true) {
    try {
      var stats = fs.statSync(fn);
      if (stats.isDirectory())
        break;
      throw new Error('Unable to create directory at '+fn);
    }
    catch (e) {
      pathsNotFound.push(fn);
      fn = path.dirname(fn);
    }
  }
  for (var i=pathsNotFound.length-1; i>-1; i--) {
    var fn = pathsNotFound[i];
    console.log("mkdir:\t\033[90mmaking directory\033[0m " + fn);
    fs.mkdirSync(fn, mode);
  }
};

function streamData(prefix, data) {
    var lines = data.toString().split(/\r\n|\n|\r/g);
    for (var i = 0, len = lines.length-1; i < len; i++) {
        sys.print(prefix);
        sys.print(lines[i]);
        sys.print("\n");
    }
    if (lines[lines.length-1]) {
        sys.print(prefix);
        sys.print(lines[lines.length-1]);
    }
}

function doLumbar(dir, package, watch, minimize, configFile, complete) {
    var args = [
        '--config', configFile || './config/dev.json',
        "./lumbar.json",
        (dir || '.')
    ];
    if (package) {
      args.push('--module');
      args.push(package);
    }
    if (watch) {
        args.push('--watch');
    }
    if (minimize) {
        args.push('--minimize');
    }

    var lumbar = child_process.spawn(__dirname + '/node_modules/lumbar/bin/lumbar', args);
    lumbar.stdout.on('data', function (data) {
        streamData('lumbar: ', data);
    });
    lumbar.stderr.on('data', function (data) {
        streamData('lumbar err: ', data);
    });

    lumbar.on('exit', function(code) {
      complete || growl.notify('Lumbar Borked', { title: 'Lumbar Borked', sticky: true });

      complete && complete(code)
    });
}

desc("The default task. Executes init");
task("default", ['init'], function() {});

desc("Initializes the public directory for all content that is not included in the repository")
task("init", ['lumbar'], function() {});

desc("Process all lumbar modules.")
task("lumbar", [], function() {
    doLumbar('public', false, false, false, undefined, complete);
}, true);

desc("Initializes the file change watcher");
task("watch", [], function() {
    doLumbar('public', false, true);
});

desc("Builds production packages");
task("release", [], function(prefix, package) {
  prefix = prefix || 'todo';
  jake.Task['build_core'].invoke(prefix, package);

  doLumbar('build/' + prefix, package, false, true, './config/production.json', function(code) {
    if (code) {
      process.exit(code);
    } else {
      complete()
    }
  });
});

task("build_core", ["clean"], function(prefix, package) {
    prefix = prefix || 'todo';
    mkdir('build/' + prefix);
    mkdir('build/' + prefix + '/js');
});

desc("Cleans any generated content out of the application");
task("clean", [], function() {
    glob.globSync('public/*.css').forEach(fs.unlinkSync);
    glob.globSync('public/**/*.js').forEach(fs.unlinkSync);
    glob.globSync('build').forEach(wrench.rmdirSyncRecursive);
    glob.globSync('public/js').forEach(wrench.rmdirSyncRecursive);
    glob.globSync('public/@2x').forEach(wrench.rmdirSyncRecursive);
    glob.globSync('public/@1.5x').forEach(wrench.rmdirSyncRecursive);
});
