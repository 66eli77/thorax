
<html>
  <head>
    <meta charset="utf-8">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Thorax: Backbone + Handlebars</title>
    
    <link rel="stylesheet" type="text/css" href="http://documentup.com/stylesheets/screen.css">
    
    

    
  <style>#content #title {
  font-family: Georgia, serif;
  background-image:url("logo.png"); 
  background-repeat:no-repeat;
  padding-left:80px;
  font-size:72px;
  padding-bottom:10px;
  margin-bottom:0;
  color:#333;
}

#content h3.signature {
  font-weight:bold;
}

#content h3.signature em {
  font-size: 0.7em;
  font-style:normal; 
  font-weight:normal;
  padding-left:15px;
  font-family: Consolas,"Andale Mono WT","Andale Mono","Lucida Console","Lucida Sans Typewriter","DejaVu Sans Mono","Bitstream Vera Sans Mono","Liberation Mono","Nimbus Mono L",Monaco,"Courier New",Courier,monospace;
}
</style></head>
  <body><div id="container">
  <div id="nav">
    
      <div id="header">
        <a href="#" id="logo">thorax</a>
      </div>
    
    <ul id="sections">
      
        <li>
          <a href="#overview">Overview</a>
          
            <ul>
              
                <li>
                  <a href="#overview/quick-start">Quick Start</a>
                </li>
              
                <li>
                  <a href="#overview/project-structure">Project Structure</a>
                </li>
              
            </ul>
          
        </li>
      
        <li>
          <a href="#configuration">Configuration</a>
          
            <ul>
              
                <li>
                  <a href="#configuration/configure-thorax-configure-options">configure </a>
                </li>
              
            </ul>
          
        </li>
      
        <li>
          <a href="#routers-layout">Routers &amp; Layout</a>
          
            <ul>
              
                <li>
                  <a href="#routers-layout/create-application-router-create-module-protoprops-classprops">create </a>
                </li>
              
                <li>
                  <a href="#routers-layout/view-router-view-name-attributes">view </a>
                </li>
              
                <li>
                  <a href="#routers-layout/layout-application-layout">layout </a>
                </li>
              
                <li>
                  <a href="#routers-layout/setview-application-layout-setview-view">setView </a>
                </li>
              
                <li>
                  <a href="#routers-layout/view-lifecycle-events">View Lifecycle Events</a>
                </li>
              
                <li>
                  <a href="#routers-layout/anchorclick-application-layout-anchorclick">anchorClick </a>
                </li>
              
            </ul>
          
        </li>
      
        <li>
          <a href="#loading-data">Loading Data</a>
          
            <ul>
              
                <li>
                  <a href="#loading-data/load-model-collection-load-callback-failback-options">load </a>
                </li>
              
                <li>
                  <a href="#loading-data/bindtoroute-router-bindtoroute-callback-failback">bindToRoute </a>
                </li>
              
            </ul>
          
        </li>
      
        <li>
          <a href="#events">Events</a>
          
            <ul>
              
                <li>
                  <a href="#events/events-application-view-events">events </a>
                </li>
              
                <li>
                  <a href="#events/nested-nested-eventname-selector">nested </a>
                </li>
              
                <li>
                  <a href="#events/registerevents-application-view-registerevents-events">registerEvents </a>
                </li>
              
                <li>
                  <a href="#events/unregisterevents-application-view-unregisterevents-event">unregisterEvents </a>
                </li>
              
                <li>
                  <a href="#events/freeze-view-freeze-options">freeze </a>
                </li>
              
                <li>
                  <a href="#events/_addevent-view-_addevent-params">_addEvent </a>
                </li>
              
            </ul>
          
        </li>
      
        <li>
          <a href="#templating">Templating</a>
          
            <ul>
              
                <li>
                  <a href="#templating/name-view-name">name </a>
                </li>
              
                <li>
                  <a href="#templating/registerhelper-application-view-registerhelper-name-callback">registerHelper </a>
                </li>
              
                <li>
                  <a href="#templating/template-view-template-name-attributes">template </a>
                </li>
              
                <li>
                  <a href="#templating/view-view-view-name-attributes">view </a>
                </li>
              
                <li>
                  <a href="#templating/html-view-html-content">html </a>
                </li>
              
                <li>
                  <a href="#templating/render-view-render-content">render </a>
                </li>
              
                <li>
                  <a href="#templating/setmodel-view-setmodel-model-options">setModel </a>
                </li>
              
                <li>
                  <a href="#templating/context-view-context-model">context </a>
                </li>
              
                <li>
                  <a href="#templating/setcollection-view-setcollection-collection-options">setCollection </a>
                </li>
              
                <li>
                  <a href="#templating/itemcontext-view-itemcontext-model-index">itemContext </a>
                </li>
              
                <li>
                  <a href="#templating/rendercollection-view-rendercollection">renderCollection </a>
                </li>
              
                <li>
                  <a href="#templating/renderitem-view-renderitem-model-index">renderItem </a>
                </li>
              
                <li>
                  <a href="#templating/renderempty-view-renderempty">renderEmpty </a>
                </li>
              
                <li>
                  <a href="#templating/emptycontext-view-emptycontext">emptyContext </a>
                </li>
              
                <li>
                  <a href="#templating/appenditem-view-appenditem-item-index">appendItem </a>
                </li>
              
            </ul>
          
        </li>
      
        <li>
          <a href="#form-handling">Form Handling</a>
          
            <ul>
              
                <li>
                  <a href="#form-handling/serialize-view-serialize-event-callback-options">serialize </a>
                </li>
              
                <li>
                  <a href="#form-handling/populate-view-populate-attributes">populate </a>
                </li>
              
                <li>
                  <a href="#form-handling/validateinput-view-validateinput-attributes">validateInput </a>
                </li>
              
            </ul>
          
        </li>
      
        <li>
          <a href="#mixins">Mixins</a>
          
            <ul>
              
                <li>
                  <a href="#mixins/registermixin-application-view-registermixin-name-callback-methods">registerMixin </a>
                </li>
              
                <li>
                  <a href="#mixins/mixin-view-mixin-name">mixin </a>
                </li>
              
            </ul>
          
        </li>
      
        <li>
          <a href="#command-line-interface">Command Line Interface</a>
          
            <ul>
              
                <li>
                  <a href="#command-line-interface/create-thorax-create-project-name">create </a>
                </li>
              
                <li>
                  <a href="#command-line-interface/router-thorax-router-module-name">router </a>
                </li>
              
                <li>
                  <a href="#command-line-interface/view-thorax-view-module-name-view-name">view </a>
                </li>
              
                <li>
                  <a href="#command-line-interface/collection-view-thorax-collection-view-module-name-view-name">collection-view </a>
                </li>
              
                <li>
                  <a href="#command-line-interface/model-thorax-model-module-name-model-name">model </a>
                </li>
              
                <li>
                  <a href="#command-line-interface/collection-thorax-collection-module-name-collection-name">collection </a>
                </li>
              
                <li>
                  <a href="#command-line-interface/watch-lumbar-watch-lumbar-json-location-output-directory">watch </a>
                </li>
              
                <li>
                  <a href="#command-line-interface/build-lumbar-build-lumbar-json-location-output-dir">build </a>
                </li>
              
                <li>
                  <a href="#command-line-interface/server-bin-server-port-number">server </a>
                </li>
              
            </ul>
          
        </li>
      
        <li>
          <a href="#change-log">Change Log</a>
          
            <ul>
              
                <li>
                  <a href="#change-log/1-2">1.2</a>
                </li>
              
                <li>
                  <a href="#change-log/1-1">1.1</a>
                </li>
              
            </ul>
          
        </li>
      
    </ul>
    
      <div class="extra" id="github">
        <a href="https://github.com/walmartlabs/thorax">Source on Github</a>
      </div>
      
        <div class="extra" id="github-issues">
          <a href="https://github.com/walmartlabs/thorax/issues">Issues</a>
        </div>
      
      
    
    
  </div>
  <div id="content">
    
      <a href="http://github.com/walmartlabs/thorax" id="github-ribbon"><img src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"></a>
    
    <h1 id="title">Thorax</h1>

    <h3>Current version: 1.2.3<br/><a href="beta">2.0 Beta Now Available</a></h3>

<p>An opinionated Backbone application framework providing a filesystem structure, on demand module loading, model and collection view binding, inheritable view and DOM events, data loading helpers, form serialization / population and validation. Built using <a href="http://documentcloud.github.com/backbone/">Backbone</a>, <a href="http://documentcloud.github.com/underscore/">Underscore</a>, <a href="https://github.com/madrobby/zepto">Zepto</a>, <a href="http://www.handlebarsjs.com/">Handlebars</a>, <a href="http://learnboost.github.com/stylus/">Stylus</a> and <a href="http://walmartlabs.github.com/lumbar">Lumbar</a>.

</p>


<h3 id="overview/quick-start">Quick Start</h3>
<p>Thorax can be used <a href="https://github.com/walmartlabs/thorax/blob/master/thorax.js">standalone</a> but is designed to work best with <a href="http://walmartlabs.github.com/lumbar">Lumbar</a>. The easiest way to setup a new Thoax + Lumbar project is with the thorax command line tool or by <a href="https://github.com/walmartlabs/thorax-example">downloading the sample project</a> it creates. To use the command line tools you'll need <a href="http://nodejs.org/">node</a> and <a href="http://npmjs.org/">npm</a>.

</p>
<pre><code><span class="title">npm</span> install -g lumbar thorax
<span class="title">thorax</span> create project-name
<span class="title">cd</span> project-name
<span class="title">lumbar</span> build lumbar.json public
<span class="title">bin</span>/server <span class="number">8000</span></code></pre>
<p>This will create a hello world project, for a more complete example clone the <a href="https://github.com/walmartlabs/thorax-todos">Thorax Todos</a> project (<a href="http://walmartlabs.github.com/thorax-todos/">demo</a>).

</p>
<h3 id="overview/project-structure">Project Structure</h3>
<ul>
<li><code>bin</code> - executable node scripts</li>
<li><code>generators</code> - code generation templates used by the <a href="#command">command line interface</a></li>
<li><code>js</code> - application code, models, collections, views, routers</li>
<li><code>lumbar.json</code> - <a href="http://walmartlabs.github.com/lumbar">see Lumbar docs</a></li>
<li><code>static</code> - static files / assets that will end up in the <code>public</code> folder</li>
<li><code>styles</code></li>
<li><code>templates</code> </li>
<li><code>thorax.json</code> - configuration for the <a href="#command">command line interface</a></li>
</ul>
<h2 id="configuration">Configuration</h2>
<h3 id="configuration/configure-thorax-configure-options" class="signature">configure <em>Thorax.configure(options)</em></h3>
<p>Start Thorax and create the <code>Application.layout</code> object.

</p>
<ul>
<li><code>layout</code> - string css selector or Element where the <code>Application.layout</code> object will attach, defaults to <code>.layout</code></li>
<li><code>scope</code> - object scope to configure, defaults to a new object in the global scope <code>Application</code></li>
<li><code>templatePathPrefix</code> - Path where your templates are located. Defaults to "templates/"</li>
</ul>
<h2 id="routers-layout">Routers &amp; Layout</h2>
<p>In your <code>lumbar.json</code> file you can specify the modules that compose your application. Each module is composed of routes, scripts, styles and templates. Thorax + Lumbar creates an internal router that listens to all routes in the application, lazily loading modules then calling a method on the router in that module as you would normally expect in a Backbone application.
</p>
<h3 id="routers-layout/create-application-router-create-module-protoprops-classprops" class="signature">create <em>Application.Router.create(module, protoProps [,classProps])</em></h3>
<p>Generate an <code>Application.Router</code> subclass. The <code>module</code> object will be automatically available inside the router file. Thorax expects that you create one router of the same name as the module, per module. In the example project there is a <code>hello-world</code> module and a corresponding <code>js/routers/hello-world.js</code> file.

</p>
<pre><code><span class="tag">Application</span><span class="class">.Router</span><span class="class">.create</span>(<span class="tag">module</span>, <span class="rules">{
  <span class="rule"><span class="attribute">index</span>:<span class="value"> <span class="function">function()</span> {</span>}</span></span>
});</code></pre>
<p>Each router method should redirect to another router method or call <code>Application.layout.setView</code>

</p>
<h3 id="routers-layout/view-router-view-name-attributes" class="signature">view <em>router.view(name [,attributes])</em></h3>
<p>Create a new view instance, looking it up by the <code>name</code> property in the view's class definition.

</p>
<h3 id="routers-layout/layout-application-layout" class="signature">layout <em>Application.layout</em></h3>
<p>Displays and manages views. By default there is only one layout object, <code>Application.layout</code> which is created then attached to the page when <code>Thorax.configure</code> is called. Additional layout objects having all of the same functionality as <code>Application.layout</code> can be created by calling <code>new Thorax.Layout()</code>.

</p>
<h3 id="routers-layout/setview-application-layout-setview-view" class="signature">setView <em>Application.layout.setView(view)</em></h3>
<p>Append the view to the <code>Application.layout</code> object, displaying it on the page.

</p>
<pre><code>routerMethod: <span class="function"><span class="keyword">function</span><span class="params">(id)</span> {</span>
  <span class="keyword">var</span> view = <span class="keyword">this</span>.view(<span class="string">'view/name'</span>);
  view.bind(<span class="string">'ready'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    view.$(<span class="string">'input:first'</span>)[<span class="number">0</span>].focus();
  });
  Application.layout.setView(view);
}</code></pre>
<p>This will trigger two events on the <code>layout</code> object, both of which will receive the new view and the old view (if present):

</p>
<ul>
<li><code>change:view:start</code> - immediately after <code>setView</code> call</li>
<li><code>change:view:end</code> - old view destroyed, new view in DOM and ready</li>
</ul>
<h3 id="routers-layout/view-lifecycle-events">View Lifecycle Events</h3>
<p>By calling <code>setView</code> on a layout object various events will be triggered on the view passed and the previous view that was passed if any.

</p>
<ul>
<li><code>initialize:before</code> - during constructor call, before <em>initialize</em> has been called</li>
<li><code>initialize:after</code> - during construcor call, after <em>initialize</em> has been called</li>
<li><code>activated</code> - immediately after <em>setView</em> was called with the view</li>
<li><code>ready</code> - <em>view.el</em> attached to parent</li>
<li><code>deactivated</code> - <em>setView</em> called with the next view, <em>view.el</em> still attached to parent</li>
<li><code>destroyed</code> - after the <em>view.el</em> has been removed from parent, immediately before <em>view.el</em> and child views are destroyed</li>
</ul>
<h3 id="routers-layout/anchorclick-application-layout-anchorclick" class="signature">anchorClick <em>Application.layout.anchorClick</em></h3>
<p>Layout objects listen for <code>click a</code> on all elements inside them (therefore inside any views passed to <code>setView</code>), triggering the corresponding route if one matches when clicked. Add a <code>data-external</code> attribute on links you want to be ignored by anchorClick.

</p>
<pre><code><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"#/internal"</span></span>Internal<span class="tag">&lt;/<span class="title">a</span></span>
<span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"/external"</span> <span class="attribute">data-external</span>=<span class="value">"true"</span></span>External<span class="tag">&lt;/<span class="title">a</span></span></code></pre>
<h2 id="loading-data">Loading Data</h2>
<p>Thorax is primarily a view framework but provides <code>Thorax.Model</code> and <code>Thorax.Collection</code> classes which should be used when passed to <code>setModel</code> or <code>setCollection</code>. These are subclassed as <code>Application.Model</code> and <code>Application.Collection</code> in all of the example projects.

</p>
<h3 id="loading-data/load-model-collection-load-callback-failback-options" class="signature">load <em>model/collection.load(callback [,failback [,options]])</em></h3>
<p>Calls <code>fetch</code> on the model or collection ensuring the callbacks will only be called if the route does not change. <code>callback</code> and <code>failback</code> will be used as arguments to <code>bindToRoute</code>. <code>options</code> will be passed to the <code>fetch</code> call on the model or collection if present.

</p>
<pre><code>routerMethod: <span class="function"><span class="keyword">function</span><span class="params">(id)</span> {</span>
  <span class="keyword">var</span> view = <span class="keyword">this</span>.view(<span class="string">'view/name'</span>);
  <span class="keyword">var</span> model = <span class="keyword">new</span> Application.Model({id: id});
  model.load(_.bind(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="comment">//callback only called if browser still on this route</span>
    view.setModel(model);
    Application.layout.setView(view);
  }, <span class="keyword">this</span>), <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="comment">//failback only called if browser has left this route</span>
  });
}</code></pre>
<h3 id="loading-data/bindtoroute-router-bindtoroute-callback-failback" class="signature">bindToRoute <em>router.bindToRoute(callback [,failback])</em></h3>
<p>Used by <code>model/collection.load</code>. Binds the callback to the current route. If the browser navigtates to another route in the time between when the callback is bound and when it is executed, callback will not be called. Else failback will be called if present.

</p>
<pre><code>routerMethod: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  <span class="keyword">var</span> callback = <span class="keyword">this</span>.bindToRoute(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="comment">//callback called if browser is still on route</span>
  });
  setTimeout(callback, <span class="number">5000</span>);
}</code></pre>
<h2 id="events">Events</h2>
<p>Thorax adds to Backbone's event handling by enhancing the <code>view.events</code> hash, and providing a way of registering events for all views with <code>registerEvents</code> and <code>unregisterEvents</code>.

</p>
<h3 id="events/events-application-view-events" class="signature">events <em>Application.View.events</em></h3>
<p>Thorax enhances the <code>Backbone.View.events</code> hash handling in the following ways:

</p>
<ul>
<li>accepts functions as a value to the hash in addition to a string method name</li>
<li>accepts non DOM event names that will be treated as view events</li>
<li>accepts a <code>collection</code> or <code>model</code> hash of events that will be bound to the model or collection when <code>setModel</code> or <code>setCollection</code> are called, callbacks will be called with a context of the view instance</li>
</ul>
<p>An example of a view implementing all of the above:

</p>
<pre><code>Application.View.extend({
  name: <span class="string">'view-name'</span>,
  events: {
    custom: <span class="string">'_onCustom'</span>,
    <span class="string">'click a'</span>: <span class="string">'_onClick'</span>,
    model: {
      change: <span class="string">'_onChange'</span>
    },
    collection: {
      add: <span class="function"><span class="keyword">function</span><span class="params">(model)</span>{</span>}
    }
  },
  _onCustom: <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>},
  _onClick: <span class="function"><span class="keyword">function</span><span class="params">(event)</span>{</span>},
  _onChange: <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>}
});</code></pre>
<h3 id="events/nested-nested-eventname-selector" class="signature">nested <em>nested eventName [selector]</em></h3>
<p>If a view has child views, the parent view by default will only listen for events triggered directly on the parent or DOM elements belonging directly to the parent, and not the children. The <code>nested</code> keyword can be used in the <code>events</code> hash or in a hash passed to <code>registerEvents</code> to listen for events triggered by the parents or it's children. 

</p>
<pre><code>Application.View.extend({
  name: <span class="string">'parent'</span>,
  events: {
    <span class="string">'nested eventName'</span>: <span class="function"><span class="keyword">function</span><span class="params">(view, arg)</span> {</span>
      <span class="comment">//called with a context of parent, the triggering</span>
      <span class="comment">//view is always passed as the first argument followed</span>
      <span class="comment">//by any other arguments passed to trigger, if any</span>
    },
    <span class="string">'nested click'</span>: <span class="function"><span class="keyword">function</span><span class="params">(event)</span> {</span>
      <span class="comment">//always called with a context of parent</span>
    }
  }
});</code></pre>
<h3 id="events/registerevents-application-view-registerevents-events" class="signature">registerEvents <em>Application.View.registerEvents(events)</em></h3>
<p>Add events to all instances of a view. Accepts a hash in the same format as described in <code>Application.View.events</code>

</p>
<pre><code>Application.View.registerEvents({
  'click a': <span class="keyword">function</span>() {
    //called <span class="keyword">on</span> any a click <span class="keyword">for</span> <span class="keyword">all</span> instances
    //<span class="keyword">and</span> subclasses <span class="keyword">of</span> Application.View
  }
});

Subclass = Application.View.extend({});
Subclass.registerEvents({
  //events <span class="keyword">for</span> <span class="keyword">all</span> instances <span class="keyword">and</span> subclasses <span class="keyword">of</span> Subclass
});</code></pre>
<h3 id="events/unregisterevents-application-view-unregisterevents-event" class="signature">unregisterEvents <em>Application.View.unregisterEvents([event])</em></h3>
<p>Unregister events for all instances and subclasses of a given view class. Note that calling <code>unregisterEvents</code> on <code>Application.View</code> will unregister the built in events that make <code>setModel</code> and <code>setCollection</code> work. 

</p>
<pre><code>Subclass.unregisterEvents(); //all events
Application.View.unregisterEvents(<span class="comment">'click a');</span>
Application.View.unregisterEvents(<span class="comment">'model', 'change');</span></code></pre>
<h3 id="events/freeze-view-freeze-options" class="signature">freeze <em>view.freeze([options])</em></h3>
<p><code>setModel</code> and <code>setCollection</code> add event handlers to the view, call freeze to remove them. <code>options</code> may contain a <code>model</code> or <code>collection</code> key that should contain the model or collection that was set with <code>setModel</code> or <code>setCollection</code>.

</p>
<h3 id="events/_addevent-view-_addevent-params" class="signature">_addEvent <em>view._addEvent(params)</em></h3>
<p>This method is never called directly, but can be specified to override the behavior of the <code>events</code> hash or a hash passed to <code>registerEvents</code>. For each event passed <code>_addEvent</code> will be called with a hash containing:

</p>
<ul>
<li>type "view" || "DOM"</li>
<li>name (DOM events will begin with ".delegateEvents")</li>
<li>originalName</li>
<li>selector (DOM events only)</li>
<li>handler</li>
<li>nested (Boolean)</li>
</ul>
<h2 id="templating">Templating</h2>
<p>Thorax provides deep integration with <a href="http://www.handlebarsjs.com">Handlebars</a>. By default one view maps to one Handlebars template of the same name. View attributes are made automatically availble to template as are model attributes if a model was set on a view with <code>setModel</code>. Views having a collection set via <code>setCollection</code> will look for corresponding <code>view-name-item.handlebars</code> and <code>view-name-empty.handlebars</code> templates. The <code>view</code> and <code>template</code> helpers are provided to allow the direct inclusion of other views or templates inside of templates.

</p>
<h3 id="templating/name-view-name" class="signature">name <em>view.name</em></h3>
<p>Every view descending from Application.View must have a name attribute. <code>render</code> will look for a corresponding handlebars template of the same name.

</p>
<pre><code><span class="constant">Application</span>.<span class="constant">View</span>.<span class="identifier"><span class="keymethods">extend</span></span>({
  <span class="identifier"><span class="keymethods">name</span></span><span class="symbol">:</span> <span class="string">'view-name'</span>
  /<span class="regexp">/ templates/view</span>-<span class="identifier"><span class="keymethods">name</span></span>.<span class="identifier">handlebars</span> <span class="identifier">should</span> <span class="identifier">exist</span>
});</code></pre>
<p><code>Application.Router</code> and <code>Application.View</code> instances both have a <code>view</code> method that will look up the view class by name and create new instance.

</p>
<pre><code><span class="title">var</span> <span class="class"><span class="keyword">instance</span> = this.view('view-name');</span></code></pre>
<p>Each DOM element on the page containing a view will have the name set on the <code>data-view-name</code> attribute, allowing you to style your views with the following selector:

</p>
<pre><code><span class="attr_selector">[data-view-name="view-name"]</span> <span class="rules">{
  <span class="rule"><span class="attribute">font-size</span>:<span class="value"> <span class="number">2</span>em</span>;</span>
<span class="rule">}</span></span></code></pre>
<h3 id="templating/registerhelper-application-view-registerhelper-name-callback" class="signature">registerHelper <em>Application.View.registerHelper(name, callback)</em></h3>
<p>Register a new helper that will be available in all handlebars templates. HTML generated from helpers should always be returned in a new <code>Handlebars.SafeString</code> object.

</p>
<pre><code>Application.View.registerHelper(<span class="string">'bold'</span>, <span class="function"><span class="keyword">function</span><span class="params">(content, options)</span> {</span>
  <span class="comment">//options.hash contains key, value pairs from named / html arguments</span>
  <span class="comment">//to the helper</span>
  <span class="keyword">return</span> <span class="keyword">new</span> Handlebars.SafeString(<span class="string">'&lt;b'</span> + content + <span class="string">'&lt;/b'</span>);
});

{{bold <span class="string">"Text"</span>}}</code></pre>
<h3 id="templating/template-view-template-name-attributes" class="signature">template <em>view.template(name [,attributes])</em></h3>
<p>Render a given template by file name sans extension. <code>render</code> and <code>renderCollection</code> both use this method. The scope inside of a template will contain all of the non function attributes of a view (which can be passed to the view constructor) and a <code>cid</code> attribute which is a unique id for each rendering of a given template.

</p>
<pre><code>var klass = Application.View.extend({
  name: 'view-name'
});
var view = new klass({
  title: 'The Title'
});    
console.log(view.template({
  body: 'The Body'
}));

// templates/view-name.handlebars
<span class="tag">&lt;<span class="title">h1</span></span><span class="variable">{{title}}</span><span class="tag">&lt;/<span class="title">h1</span></span>
<span class="tag">&lt;<span class="title">p</span></span><span class="variable">{{body}}</span><span class="tag">&lt;/<span class="title">p</span></span></code></pre>
<p>This method is also available as a template helper, it will only render the template as a string, if there is a corresponding view it will <strong>not</strong> be initialized. The scope of the current template will be carried inward to the rendred template. 

</p>
<pre><code><span class="variable">{{template "header" key="value"}}</span>
<span class="tag">&lt;<span class="title">h1</span></span><span class="variable">{{title}}</span><span class="tag">&lt;/<span class="title">h1</span></span>
<span class="tag">&lt;<span class="title">p</span></span><span class="variable">{{body}}</span><span class="tag">&lt;/<span class="title">p</span></span>
<span class="variable">{{template "footer"}}</span></code></pre>
<h3 id="templating/view-view-view-name-attributes" class="signature">view <em>view.view(name [,attributes])</em></h3>
<p>Create a new view instance, looking it up by the <code>name</code> property in the view's class definition.

</p>
<pre><code><span class="tag">Application</span><span class="class">.View</span><span class="class">.extend</span>(<span class="rules">{
  <span class="rule"><span class="attribute">name</span>:<span class="value"> <span class="string">'header'</span>
</span>}</span></span>);
<span class="tag">Application</span><span class="class">.View</span><span class="class">.extend</span>(<span class="rules">{
  <span class="rule"><span class="attribute">name</span>:<span class="value"> <span class="string">'footer'</span>
</span>}</span></span>);
<span class="tag">Application</span><span class="class">.View</span><span class="class">.extend</span>(<span class="rules">{
  <span class="rule"><span class="attribute">name</span>:<span class="value"> <span class="string">'main'</span>,
  initialize: <span class="function">function()</span> {
    this.header = this.<span class="function">view(<span class="string">'header'</span>)</span></span>;</span>
  <span class="rule">}</span></span>
});</code></pre>
<p>This method is also available as a template helper which can receive a string name of a view to initialize and append, or a reference to an already initialized view.

</p>
<pre><code>// templates/main.handlebars
<span class="variable">{{view header}}</span>
<span class="tag">&lt;<span class="title">h1</span></span><span class="variable">{{title}}</span><span class="tag">&lt;/<span class="title">h1</span></span>
<span class="tag">&lt;<span class="title">p</span></span><span class="variable">{{body}}</span><span class="tag">&lt;/<span class="title">p</span></span>
<span class="variable">{{view "footer"}}</span></code></pre>
<h3 id="templating/html-view-html-content" class="signature">html <em>view.html([content])</em></h3>
<p>Replace the HTML in a given view. The collection element and the child views appended by the <code>{{view}}</code> helper will be automatically preserved if present.

</p>
<h3 id="templating/render-view-render-content" class="signature">render <em>view.render([content])</em></h3>
<p>Render a template with the filename of the view's <code>name</code> attribute (sans extension), calling <code>view.html()</code> with the result. Triggers the <code>rendered</code> event.

</p>
<p>To implement custom rendering behavior in a subclass override the method and pass a <code>content</code> argument to render which may be an HTML string, DOM Element or an array of DOM Elements.

</p>
<pre><code><span class="tag">Application</span><span class="class">.View</span><span class="class">.extend</span>(<span class="rules">{
  <span class="rule"><span class="attribute">name</span>:<span class="value"> <span class="string">'child'</span>,
  render: <span class="function">function()</span> {
    return Application.View.prototype.render.<span class="function">call(this, <span class="string">'content'</span>)</span></span>;</span>
  <span class="rule">}</span></span>
});</code></pre>
<h3 id="templating/setmodel-view-setmodel-model-options" class="signature">setModel <em>view.setModel(model, options)</em></h3>
<p>Set the *model<code> attribute of the view. By default when the model is populated (either when it is passed to </code>setModel<code> or after it is fetched) the </code>render<code> will be called on the view, with the view's attributes and the model's </code>attributes<code> available inside of the template. A </code>change<code> event on the model (often triggered by the model's </code>set<code> method) will cause the view to call </code>render` again.

</p>
<ul>
<li><code>fetch</code> - auto fetch the model if empty, defaults to true, if an object is passed it will be used as the options to <code>fetch</code></li>
<li><code>success</code> - a callback to call when fetch() succeeds, defaults to false</li>
<li><code>render</code> - wether to call render after <em>setModel</em> and on the model's <em>change</em> event, defaults to true</li>
<li><code>populate</code> - wether to auto call <em>populate</em>, defaults to true. if there is no form in the view <em>populate</em> will have no effect</li>
<li><code>errors</code> - wether to bubble the error event from the model to the view</li>
</ul>
<p><code>setModel</code> will trigger the <code>model set</code> event:

</p>
<pre><code><span class="tag">Application</span><span class="class">.View</span><span class="class">.extend</span>(<span class="rules">{
  <span class="rule"><span class="attribute">name</span>:<span class="value"> <span class="string">'view-name'</span>,
  events: {
    model: {
      set: <span class="function">function(model)</span> {</span>}</span></span>
    }
  }
});</code></pre>
<h3 id="templating/context-view-context-model" class="signature">context <em>view.context([model])</em></h3>
<p>Specify this function to override what attributes will be passed from a model set with <code>setModel</code> to a template.

</p>
<pre><code><span class="tag">Application</span><span class="class">.View</span><span class="class">.extend</span>(<span class="rules">{
  <span class="rule"><span class="attribute">name</span>:<span class="value"> <span class="string">'view-name'</span>,
  context: <span class="function">function(model)</span> {
    return _.<span class="function">extend({}, model.attributes, {
      title: model.getTitle()</span>
    </span>}</span></span>);
  }
});</code></pre>
<h3 id="templating/setcollection-view-setcollection-collection-options" class="signature">setCollection <em>view.setCollection(collection [,options])</em></h3>
<p>Set the <em>collection</em> attribute of the view. This will bind events on collection <code>add</code>, <code>remove</code> and <code>reset</code>, updating the collection element (specified by the <code>collection</code> view helper) as needed. <code>options</code> may contain: 

</p>
<ul>
<li><code>fetch</code> - auto fetch, defaults to true, if an object is passed it will be used as the options to <code>fetch</code></li>
<li><code>success</code> - a callback to call when fetch() succeeds, defaults to false</li>
<li><code>errors</code> - wether to bubble error events from the collection to the view, defaults to true</li>
</ul>
<p>Collection rendering assumes that the following templates will be present.

</p>
<ul>
<li><code>templates/name.handlebars</code> - must contain the {{collection helper}}</li>
<li><code>templates/name-item.handlebars</code> - must have at least one outer HTML element</li>
<li><code>templates/name-empty.handlebars</code> - must have at least one outer HTML element</li>
</ul>
<p>To display a collection in your template use the <code>{{collection}}</code> view helper. You can pass a custom <code>tag</code> name (defaults to "div") or any HTML attributes.

</p>
<pre><code>{{collection tag=<span class="string">"ul"</span> <span class="class"><span class="keyword">class</span>="<span class="id">my</span>-<span class="id">list</span>"}}</span></code></pre>
<p>The following events will be triggered when the collection is rendered:

</p>
<ul>
<li><code>rendered:collection</code> - called when <code>renderCollection</code> is called, receives the the collection element</li>
<li><code>rendered:item</code> - called for each item rendered in a non empty collection after <code>renderCollection</code> is called, receives the item element or view after it has been rendered</li>
<li><code>rendered:empty</code> - called when <code>renderCollection</code> is called with an empty collection, receives the the collection element</li>
</ul>
<h3 id="templating/itemcontext-view-itemcontext-model-index" class="signature">itemContext <em>view.itemContext(model, index)</em></h3>
<p>Just like the <code>context</code> method, but called for each item in the collection.

</p>
<h3 id="templating/rendercollection-view-rendercollection" class="signature">renderCollection <em>view.renderCollection()</em></h3>
<p>Re-render the entire collection. If you need custom behavior when a collection is rendered it is better to use the <code>rendered</code> or <code>rendered:collection</code> events. This method looks for <code>this.collection</code> which should be set by <code>setCollection</code> and ignores any arguments passed.

</p>
<h3 id="templating/renderitem-view-renderitem-model-index" class="signature">renderItem <em>view.renderItem(model, index)</em></h3>
<p>Override this method to specify how an item is rendered. May return a string or another view.

</p>
<pre><code>renderItem: <span class="function"><span class="keyword">function</span><span class="params">(model)</span> {</span>
  <span class="keyword">return</span> <span class="keyword">new</span> MyItemView({
    model: model
  });
}

renderItem: <span class="function"><span class="keyword">function</span><span class="params">(model, i)</span> {</span>
  <span class="keyword">return</span> <span class="keyword">this</span>.template(<span class="keyword">this</span>.name + <span class="string">'-item'</span>, <span class="keyword">this</span>.itemContext(model, i));
}</code></pre>
<h3 id="templating/renderempty-view-renderempty" class="signature">renderEmpty <em>view.renderEmpty()</em></h3>
<p>Override this method to specify what happens when <code>renderCollection</code> is called when the collection is empty. May return a string or another view. The default implementation is:

</p>
<pre><code>renderEmpty: <span class="keyword">function</span>() {
  <span class="keyword">return</span> this.template(this.name + <span class="literal">'-empty'</span>);
}</code></pre>
<h3 id="templating/emptycontext-view-emptycontext" class="signature">emptyContext <em>view.emptyContext()</em></h3>
<p>Just like the <code>context</code> method, but called when <code>renderEmpty</code> is called.

</p>
<h3 id="templating/appenditem-view-appenditem-item-index" class="signature">appendItem <em>view.appendItem(item [,index])</em></h3>
<p>Append and item at a given index. If no index is passed the index of the model in the current collection will be used, if the first argument is not a model, 0 will be used. <code>item</code> may be:

</p>
<ul>
<li>a model which will be passed to <code>renderItem</code></li>
<li>an arbitrary html string which should contain exactly one outer element</li>
<li>a view instance</li>
</ul>
<h2 id="form-handling">Form Handling</h2>
<p>Thorax provides helpers to assist with form handling, but makes no user interface decisions for you. Use the <code>validate</code> and <code>error</code> events to implement error messages in your application.

</p>
<pre><code>Application.View.registerEvents({
  validate: <span class="function"><span class="keyword">function</span><span class="params">(attributes, errors)</span></span> {
    //clear previous errors <span class="keyword">if</span> present
  },
  <span class="built_in">error</span>: <span class="function"><span class="keyword">function</span><span class="params">(errors)</span></span> {
    errors.forEach(<span class="function"><span class="keyword">function</span><span class="params">(error)</span></span> {
      //lookup input by <span class="built_in">error</span>.name
      //display <span class="built_in">error</span> from <span class="built_in">error</span>.message
    });
  }
});</code></pre>
<h3 id="form-handling/serialize-view-serialize-event-callback-options" class="signature">serialize <em>view.serialize([event], callback [,options])</em></h3>
<p>Serializes a form. <code>callback</code> will receive the attributes from the form and will only be called if <code>validateInput</code> returns nothing or an empty array. If an <code>event</code> is passed a check will be run to prevent duplicate submission. <code>options</code> may contain:

</p>
<ul>
<li><code>set</code> - defaults to true, wether or not to set the attributes if valid on a model if one was set with <code>setModel</code></li>
<li><code>validate - defaults to true, wether or not to call </code>validateInput` during serialization</li>
</ul>
<p>Each form input in your application should contain a corresponding label. Since you may want to re-use the same form multiple times in the same view a <code>cid</code> attribute with a unique value is provided to each render call of each template:

</p>
<pre><code><span class="tag">&lt;<span class="title">label</span> <span class="attribute">for</span>=<span class="value">"<span class="variable">{{cid}}</span>-last-name"</span>/</span>
<span class="tag">&lt;<span class="title">input</span> <span class="attribute">name</span>=<span class="value">"last-name"</span> <span class="attribute">id</span>=<span class="value">"<span class="variable">{{cid}}</span>-last-name"</span> <span class="attribute">value</span>=<span class="value">"Beastridge"</span>/</span>
<span class="tag">&lt;<span class="title">label</span> <span class="attribute">for</span>=<span class="value">"<span class="variable">{{cid}}</span>-last-name"</span>/</span>
<span class="tag">&lt;<span class="title">input</span> <span class="attribute">name</span>=<span class="value">"address[street]"</span> <span class="attribute">value</span>=<span class="value">"123 Chestnut"</span> <span class="attribute">id</span>=<span class="value">"<span class="variable">{{cid}}</span>-address[street]"</span>/</span>

Phoenix.View.extend({
  name: "address-form",
  events: {
    "submit form": "_handleSubmit"
  },
  _handleSubmit: function(event) {
    this.serialize(event, function(attributes) {
      attributes["last-name"] === "Beastridge";
      attributes.address.street === "123 Chestnut";
    });
  }
});</code></pre>
<p><code>serialize</code> Triggers the following events:

</p>
<ul>
<li><code>serialize</code> - called before validation with serialized attributes</li>
<li><code>validate</code> - with an attributes hash and errors array after <code>validateInput</code> is called</li>
<li><code>error</code> - with an errors array, if validateInput returned an array with any errors</li>
</ul>
<p>If your view uses inputs with non standard names (or no names, multiple inputs with the same name, etc), use the <code>serialize</code> event:

</p>
<pre><code><span class="keyword">this</span>.bind(<span class="string">'serialize'</span>, _.bind(<span class="function"><span class="keyword">function</span><span class="params">(attributes)</span> {</span>
  attributes.custom = <span class="keyword">this</span>.$(<span class="string">'.my-input'</span>).val();
}, <span class="keyword">this</span>));</code></pre>
<h3 id="form-handling/populate-view-populate-attributes" class="signature">populate <em>view.populate([attributes])</em></h3>
<p>Populate the form fields in the view with the given attributes. The keys of the attributes should correspond to the names of the inputs. <code>populate</code> is automatically called with the response from <code>view.context(view.model.attributes)</code> when <code>setModel</code> is called.

</p>
<pre><code>view.populate({
  <span class="comment">"last-name"</span>: <span class="comment">"Beastridge"</span>
  <span class="method">address:</span> {
    <span class="method">street:</span> <span class="comment">"123 Chestnut"</span>
  }
});</code></pre>
<p><code>populate</code> triggers a <code>populate</code> event. If your view uses inputs with non standard names (or no names, multiple inputs with the same name, etc), use this event:

</p>
<pre><code><span class="keyword">this</span>.bind(<span class="string">'populate'</span>, _.bind(<span class="function"><span class="keyword">function</span><span class="params">(attributes)</span> {</span>
  <span class="keyword">this</span>.$(<span class="string">'.my-input'</span>).val(attributes.custom);
}, <span class="keyword">this</span>));</code></pre>
<h3 id="form-handling/validateinput-view-validateinput-attributes" class="signature">validateInput <em>view.validateInput(attributes)</em></h3>
<p>Validate the attributes created by <code>serialize</code>, must return an array or nothing (if valid). It's recommended that the array contain hashes with <code>name</code> and <code>message</code> attributes, but arbitrary data or objects may be passed. If the array has a zero length the attributes are considered to be valid. Returning an array with any errors will trigger the <code>error</code> event.

</p>
<pre><code>validateInput: <span class="function"><span class="keyword">function</span><span class="params">(attributes)</span> {</span>
  <span class="keyword">var</span> errors = [];
  <span class="keyword">if</span> (attributes.password &amp;&amp; !attributes.password.match(<span class="regexp">/.{6,11}/</span>)) {
    errors.push({name: <span class="string">'password'</span>, message: <span class="string">'Invalid Password'</span>});
  }
  <span class="keyword">return</span> errors;
}</code></pre>
<h2 id="mixins">Mixins</h2>
<h3 id="mixins/registermixin-application-view-registermixin-name-callback-methods" class="signature">registerMixin <em>Application.View.registerMixin(name, callback, methods)</em></h3>
<p>Create a named mixin. Callback will be called with the context of the view instance calling <code>mixin</code>. <code>methods</code> will be added to the view instance.

</p>
<pre><code>Application.View.registerMixin(<span class="string">'mixin-name'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>

}, {
  methodName: <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>}
});

Application.View.extend({
  name: <span class="string">'view-name'</span>,
  initialize: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">this</span>.mixin(<span class="string">'mixin-name'</span>);
  }
});</code></pre>
<h3 id="mixins/mixin-view-mixin-name" class="signature">mixin <em>view.mixin(name)</em></h3>
<p>Apply a given mixin by name. The mixin will only be applied once, thus duplicate calls <code>mixin</code> with the same <code>name</code> will not cause the mixin callback to be run multiple times.

</p>
<h2 id="command-line-interface">Command Line Interface</h2>
<p>It is possible to use the main <a href="https://github.com/walmartlabs/thorax/blob/master/thorax.js">thorax.js</a> library completely standalone, but all of the documentation will assume you will be using a project structure created by the command line interface. To install the command line tools run:

</p>
<pre><code><span class="title">npm</span> install -g lumbar thorax</code></pre>
<h3 id="command-line-interface/create-thorax-create-project-name" class="signature">create <em>thorax create $project-name</em></h3>
<p>Create a new thorax project. All other thorax commands are run from inside the project directory.

</p>
<pre><code><span class="title">thorax</span> create todos
<span class="title">cd</span> todos</code></pre>
<h3 id="command-line-interface/router-thorax-router-module-name" class="signature">router <em>thorax router $module-name</em></h3>
<p>Generate a router class and a module of the same name. A module is defined in <em>lumbar.json</em> and is composed of models, collections, views, templates, styles and a single router. Lumbar combines these files into a single js and single css file which are lazily loaded when one of the module's route's is visited. Running:

</p>
<pre><code><span class="title">thorax</span> router todos</code></pre>
<ul>
<li>creates: app/routers/todos.js</li>
<li>adds a JSON fragment for the <em>todos</em> module in <em>lumbar.json</em></li>
</ul>
<p>You'll need to fill in the <em>routes</em> hash inside <em>lumbar.json</em> with path: method name pairs to match your router class. This is how Lumbar / Thorax work together to lazily load your modules.

</p>
<h3 id="command-line-interface/view-thorax-view-module-name-view-name" class="signature">view <em>thorax view $module-name $view-name</em></h3>
<p>Generate a view class and template of the same name. Running:

</p>
<pre><code><span class="title">thorax</span> view todos header</code></pre>
<ul>
<li>creates: app/views/header.js</li>
<li>creates: app/templates/header.handlebars</li>
<li>adds the appropriate JSON fragments in the <em>main</em> module in <em>lumbar.json</em></li>
</ul>
<h3 id="command-line-interface/collection-view-thorax-collection-view-module-name-view-name" class="signature">collection-view <em>thorax collection-view $module-name $view-name</em></h3>
<p>Generate a view class which will render a collection and the appropriate templates of the same name. Running:

</p>
<pre><code>thorax collection-view todos todo-<span class="keyword">list</span></code></pre>
<ul>
<li>creates: todo-list.js</li>
<li>creates: app/templates/todo-list.handlebars</li>
<li>creates: app/templates/todo-list-item.handlebars</li>
<li>creates: app/templates/todo-list-empty.handlebars</li>
<li>adds the appropriate JSON fragments in the <em>main</em> module in <em>lumbar.json</em></li>
</ul>
<h3 id="command-line-interface/model-thorax-model-module-name-model-name" class="signature">model <em>thorax model $module-name $model-name</em></h3>
<p>Generate a model class. Running:

</p>
<pre><code><span class="title">thorax</span> model todos todo</code></pre>
<ul>
<li>creates: app/models/todo.js</li>
<li>adds the appropriate JSON fragments in the <em>main</em> module in <em>lumbar.json</em></li>
</ul>
<h3 id="command-line-interface/collection-thorax-collection-module-name-collection-name" class="signature">collection <em>thorax collection $module-name $collection-name</em></h3>
<p>Generate a collection class. Running:

</p>
<pre><code>thorax collection todos todo-<span class="keyword">list</span></code></pre>
<ul>
<li>creates: app/collections/todo-list.js</li>
<li>adds the appropriate JSON fragments in the <em>main</em> module in <em>lumbar.json</em></li>
</ul>
<h3 id="command-line-interface/watch-lumbar-watch-lumbar-json-location-output-directory" class="signature">watch <em>lumbar watch $lumbar-json-location $output-directory</em></h3>
<p>Watches all files, generating the appropriate JavaScript or CSS in the <code>output-directory</code> when changes occur.

</p>
<pre><code>lumbar watch ./lumbar.json ./<span class="keyword">public</span></code></pre>
<h3 id="command-line-interface/build-lumbar-build-lumbar-json-location-output-dir" class="signature">build <em>lumbar build $lumbar-json-location $output-dir</em></h3>
<p>Just like watch, but runs once then exits.

</p>
<pre><code>lumbar build ./lumbar.json ./<span class="keyword">public</span></code></pre>
<h3 id="command-line-interface/server-bin-server-port-number" class="signature">server <em>bin/server $port-number</em></h3>
<p>The example project includes a server script that will start an express server with a static provider for the <code>public</code> directory of your project.

</p>
<pre><code>.<span class="regexp">/bin/server</span> <span class="number">8000</span></code></pre>
<h2 id="change-log">Change Log</h2>
<h3 id="change-log/1-2">1.2</h3>
<ul>
<li>load:start and load:end handling have been moved into a plugin</li>
<li>nested event keyword now works with views, the callback will always be called with the context of the declaring view and will always recieve the triggering view as the first argument</li>
<li>empty() the collection element before renderCollection()</li>
</ul>
<h3 id="change-log/1-1">1.1</h3>
<ul>
<li>added {{collection}} helper</li>
<li>_collectionSelector is now deprecated and internally defaults to [data-collection-cid], for backwards compatibility set it to ".collection" in your view classes</li>
<li>added templatePathPrefix option to configure()</li>
<li>unit tests!</li>
<li>added nested event keyword</li>
<li>added _addEvent method for subclasses to customize event registration</li>
<li>registerEvents is now an instance method in addition to a class method</li>
<li>added emptyContext method, called from renderEmpty</li>
<li>checks for view.name property are now lazy</li>
<li>exceptions are now thrown instead of using console.error</li>
</ul>

  </div>
</div></body>
</html>
