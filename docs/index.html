<!DOCTYPE HTML>
<html>

<head>
  <meta http-equiv="content-type" content="text/html;charset=UTF-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <title>Phoenix View Framework</title>
  <style>    body {
      font-size: 14px;
      line-height: 22px;
      font-family: Helvetica Neue, Helvetica, Arial;
      background: #f4f4f4 url("background.png");
    }
    .interface {
      font-family: "Lucida Grande", "Lucida Sans Unicode", Helvetica, Arial, sans-serif !important;
    }
    div#sidebar {
      background: #fff;
      position: fixed;
      top: 0; left: 0; bottom: 0;
      width: 200px;
      overflow-y: auto;
      overflow-x: hidden;
      padding: 15px 0 30px 30px;
      border-right: 1px solid #ddd;
      box-shadow: 0 0 20px #ccc; -webkit-box-shadow: 0 0 20px #ccc; -moz-box-shadow: 0 0 20px #ccc;
    }
      #sidebar h2 {
        margin: 0;
        padding: 0;
        font-size: inherit;
        line-height: inherit;
        font-weight: inherit;
      }

        #sidebar h2 a, a:visited {
          display: block;
          color: black;
          font-weight: bold;
          margin-top: 15px;
        }
          #sidebar h2 a:hover {
            text-decoration: underline;
          }
      #sidebar ul {
        font-size: 11px;
        line-height: 14px;
        margin: 5px 0 0 0;
        padding-left: 0px;
        list-style-type: none;
        font-family: Lucida Grande;
      }
        #sidebar li {
          cursor: pointer;
          margin: 0 0 3px 0;

        }

        #sidebar li:before {
          content: 'â€“ ';  
        }

          #sidebar li a {
            text-decoration: none;
            color: black;
          }
            #sidebar li a:hover {
              text-decoration: underline;
            }
    div.container {
      position: relative;
      width: 550px;
      margin: 40px 0 50px 260px;
    }
    p, div.container ul {
      margin: 20px 0;
      width: 550px;
    }
      p.warning {
        font-size: 12px;
        line-height: 18px;
        font-style: italic;
      }
      div.container ul {
        list-style: circle;
        font-size: 12px;
        padding-left: 15px;
      }
    a, a:visited {
      color: #444;
    }
    a:active, a:hover {
      color: #000;
    }
    a img {
      border: 0;
    }
    h1, h2, h3, h4, h5, h6 {
      padding-top: 20px;
    }
      h2 {
        font-size: 20px;
      }
      .container h2 {
        border-top: 1px solid #CCC;
      }
    h3 {
      padding-bottom: 0;
      margin-bottom: -18px;
      font-size: 16px;
      line-height: 30px;
      white-space: nowrap;
    }

    .container h3 {
      padding-top:0;
    }

    span.alias {
      font-size: 14px;
      font-style: italic;
      margin-left: 20px;
    }
    table {
      margin: 15px 0 0; padding: 0;
    }
      tr, td {
        margin: 0; padding: 0;
      }
        td {
          padding: 0px 15px 5px 0;
        }
    code, pre, p em, .container em {
      font-family: Monaco, Consolas, "Lucida Console", monospace;
      font-size: 12px;
      line-height: 18px;
      font-style: normal;
      font-weight: normal;
    }

    .container pre {
      text-indent: -20px;
    }

      p em {
        padding: 0px 3px;
        background: #fff;
        border: 1px solid #ddd;
        zoom: 1;
      }
      code, .container h3 em {
        margin-left: 20px;
      }
      pre {
        font-size: 12px;
        padding: 2px 0 2px 15px;
        border: 4px solid #bbb; border-top: 0; border-bottom: 0;
        margin: 0px 0 30px;
      }
</style>
</head>
<body>
  <div id="sidebar" class="interface"><h2><a href="#introduction">Introduction</a></h2><h2><a href="#templates">Templates</a></h2><h2><a href="#i18n">I18N</a></h2><h2><a href="#collections">Collections</a></h2><h2><a href="#forms">Forms</a></h2><h2><a href="#phoenix-view">Phoenix.View</a></h2><ul><li><a href="#phoenix-view-name">name</a></li><li><a href="#phoenix-view-mixin">mixin</a></li><li><a href="#phoenix-view-partial">partial</a></li><li><a href="#phoenix-view-render">render</a></li><li><a href="#phoenix-view-rendertemplate">renderTemplate</a></li><li><a href="#phoenix-view-html">html</a></li><li><a href="#phoenix-view-serialize">serialize</a></li><li><a href="#phoenix-view-populate">populate</a></li><li><a href="#phoenix-view-validate">validate</a></li><li><a href="#phoenix-view-_checkfirstradio">_checkFirstRadio</a></li><li><a href="#phoenix-view-setmodel">setModel</a></li><li><a href="#phoenix-view-setcollection">setCollection</a></li><li><a href="#phoenix-view-attributes">attributes</a></li><li><a href="#phoenix-view-itemattributes">itemAttributes</a></li><li><a href="#phoenix-view-_renderitem">_renderItem</a></li><li><a href="#phoenix-view-_renderempty">_renderEmpty</a></li><li><a href="#phoenix-view-_collectionelement">_collectionElement</a></li></ul><h2><a href="#phoenix-layoutview">Phoenix.layoutView</a></h2><ul><li><a href="#phoenix-layoutview-getcurrentcard">getCurrentCard</a></li><li><a href="#phoenix-layoutview-setcard">setCard</a></li><li><a href="#phoenix-layoutview-setnexttransitionmode">setNextTransitionMode</a></li><li><a href="#phoenix-layoutview-cardselement">cardsElement</a></li><li><a href="#phoenix-layoutview-_transition">_transition</a></li><li><a href="#phoenix-layoutview-_defaulttransitionmode">_defaultTransitionMode</a></li><li><a href="#phoenix-layoutview-events">Events</a></li><li><a href="#phoenix-layoutview-transitions">Transitions</a></li></ul><h2><a href="#phoenix-views-card">Phoenix.Views.Card</a></h2><ul><li><a href="#phoenix-views-card-events">Events</a></li></ul><h2><a href="#activatable">Activatable</a></h2><ul><li><a href="#activatable-activate">activate</a></li><li><a href="#activatable-deactivate">deactivate</a></li><li><a href="#activatable-events">Events</a></li></ul><h2><a href="#loadable">Loadable</a></h2><ul><li><a href="#loadable-_loadingtimeoutduration">_loadingTimeoutDuration</a></li><li><a href="#loadable-_loadingclassname">_loadingClassName</a></li></ul><h2><a href="#orientable">Orientable</a></h2><h2><a href="#scrollable">Scrollable</a></h2><ul><li><a href="#scrollable-enablescrolling">enableScrolling</a></li><li><a href="#scrollable-disalbescrolling">disalbeScrolling</a></li><li><a href="#scrollable-scrollto">scrollTo</a></li><li><a href="#scrollable-detectscrolltobottom">detectScrollToBottom</a></li><li><a href="#scrollable-_detectscrolltobottomthreshold">_detectScrollToBottomThreshold</a></li></ul><h2><a href="#destroyable">Destroyable</a></h2><ul><li><a href="#destroyable-destroy">destroy</a></li><li><a href="#destroyable-events">Events</a></li></ul></div>
  <div class="container">
    <h2 id="introduction">Introduction</h2>

<h2 id="templates">Templates</h2>

<p>Every View should have a <em>name</em> attribute, which should be the path to the view without the filename extension for example <em>checkout/shipping-options</em>. By default each view will render a corresponding template of the same name. If the view has a <em>model</em>, the model's attributes will be passed to the template otherwise an <em>attributes</em> object or method can be specified to control what data the template recieves.</p>

<p>The <em>partial</em> method in a View will initialize another view. When used in a template it will insert the text of another template as a string, passing the scope of the calling view inward. See the <a href="#phoenix-view-partial">partial</a> method for more detail.</p>

<pre><code>Phoenix.Views.Home = Phoenix.View.extend({
  name: 'home',
  initialize: function() {
    //initializes Phoenix.Views.Footer
    this.partial('Footer');
  },
  attributes: function() {
    return {
      key: 'value'
    };
  }
});

//home.handlebars
{{{partial &quot;header&quot;}}}
&lt;h1&gt;Home&lt;/h1&gt;
&lt;p&gt;{{key}}&lt;/p&gt;
{{{Footer}}}

//header.handlebars
&lt;p&gt;{{key}}&lt;/p&gt;
</code></pre>

<h2 id="i18n">I18N</h2>

<p>All static text should be referenced using the i18n Handlebars helper.
This usage syntax is as follows <strong>{{i18n keyName [plurality]}}</strong>.  The i18n value can reference any parameters in the current Handlebars context and will be properly replaced.</p>

<ul>
<li><strong>keyName</strong>: Key reference for the i18n value.  This can be the default language value as well.</li>
<li><strong>plurality</strong>: A static number or handlebars variable which represents a number.  This can be used to reference a different value for any given key.  The plural key is in the form of keyName[0|1|2|few|many] where few = 3-9 and many is 9 or greater.</li>
</ul>

<p>The default language is specified in phoenix/js/data.js in the Phoenix.Data.I18N hash.  Some example values are:</p>

<pre><code>'foo': 'bar' // {{i18n &quot;foo&quot;}} -&gt; bar
'foo[1]': 'barSingular' // {{i18n &quot;foo&quot; 1}} -&gt; barSingular
'hello': 'hello {{name}}' // {{i18n &quot;hello&quot;}} -&gt; hello Joe  (with the context being {name: &quot;Joe&quot;})
</code></pre>

<h2 id="collections">Collections</h2>

<p>Calling <em>setCollection</em> on a view will bind events on collection <em>add</em>, <em>remove</em> and <em>reset</em>, updating the <em>_collectionElement</em> as appropriate. <em>_collectionElement</em> defaults to &quot;.collection&quot;. A view with a collection requires the following templates:</p>

<ul>
<li><strong>name.handlebars</strong></li>
<li><strong>name-item.handlebars</strong> - must have exactly one outer element</li>
<li><strong>name-empty.handlebars</strong></li>
</ul>

<p>An <em>itemAttributes</em> method can be specified which recieves each model in the collection and must return the attributes which will be passed to <em>name-item.handlebars</em>. A simple implementation might look like:</p>

<pre><code>Phoenix.Views.Shelf = Phoenix.View.extend({
  name: 'shelf',
  itemAttributes: function(model) {
    return _.extend({
      key: 'value'
    },model.attributes);
  }
});

//shelf.handlebars
&lt;h2&gt;Shelf&lt;/h2&gt;
&lt;ul class=&quot;collection&quot;&gt;&lt;/ul&gt;

//shelf-item.handlebars
&lt;li&gt;{{key}}&lt;/li&gt;

//shelf-empty.handlebars
&lt;li&gt;There are no items in the shelf.&lt;/li&gt;
</code></pre>

<h2 id="forms">Forms</h2>

<p>A basic form view might look like this:</p>

<pre><code>Phoenix.Views.AddressForm = Phoenix.View.extend({
  name: 'address-form',
  events: {
    'submit form': '_handleSubmit'
  },
  validate: function(attributes) {
    var errors = [];
    if (attributes.address.street === '') {
      errors.push({
        name: 'address[street]',
        message: 'message'
      });
    }
    if (errors.length) {
      return errors;
    }
  },
  _handleSubmit: function(event) {
    event.preventDefault();
    this.serialize(function(attributes) {
      console.log('form submission success');
    });
  }
});
</code></pre>

<p>When using <em>populate</em> and <em>serialize</em> an input with a name of <em>address[street]</em> would correspond to the object <em>address.street</em>. All form inputs should have a corresponding label. Every template has a unique <em>cid</em> property which can be used to generate unique ids:</p>

<pre><code>//address-form.handlebars
&lt;label for=&quot;{{cid}}-name&quot; class=&quot;error&quot;&gt;Street&lt;/label&gt;
&lt;input type=&quot;text&quot; name=&quot;address[street]&quot; id=&quot;{{cid}}-name&quot; value=&quot;{{street}}&quot;/&gt;
</code></pre>

<p>Calling <em>serialize</em> calls <em>validate</em> on the view, and the view's model if one was set with <em>setModel</em>. Both <em>validate</em> methods must return an array in this format:</p>

<pre><code>[
  {
    name: 'input name', //optional
    message: 'error message'
  }
]
</code></pre>

<p>Assuming the form is empty, calling <em>serialize</em> would trigger an <em>error</em> event, and the view's built in error handler would make changes to the DOM resulting in:</p>

<pre><code>&lt;label for=&quot;{{cid}}-name&quot; class=&quot;error&quot;&gt;Street &lt;span&gt;Message&lt;/span&gt;&lt;/label&gt;
&lt;input type=&quot;text&quot; name=&quot;address[street]&quot; id=&quot;{{cid}}-name&quot; value=&quot;{{street}}&quot;/&gt;
</code></pre>

<p>Errors that do not pertain to a particular field can be triggered by passing only a message. This will prepend the following HTML to the view:</p>

<pre><code>&lt;ul class=&quot;error&quot;&gt;
  &lt;li&gt;Message&lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<h2 id="phoenix-view">Phoenix.View</h2>

<h3 id="phoenix-view-name">name <em>object.name</em></h3>

<p>The path to the view without the filename extension, for example: <em>checkout/shipping-options</em></p>

<h3 id="phoenix-view-mixin">mixin <em>object.mixin(mixin_name)</em></h3>

<p>Applies the logic in the mixin, adding the methods listed in each mixin. Built-in mixins are:</p>

<ul>
<li><a href="#scrollable">Scrollable</a></li>
<li><a href="#activatable">Activatable</a></li>
<li><a href="#loadable">Loadable</a></li>
<li><a href="#destroyable">Destroyable</a></li>
<li><a href="#orientable">Orientable</a></li>
</ul>

<h3 id="phoenix-view-partial">partial <em>object.partial(view_class_name,[,attributes [,options]])</em></h3>

<p>Initializes a child view, making it available to any template rendered by parent view. Inside the template it will be inserted as. Calling <em>partial()</em> with the same view subsequent times will return the instance created on the first call.</p>

<pre><code>this.partial('Footer');

//template.handlebars
{{{Footer}}}
</code></pre>

<p>Note that the <em>el</em> node from the Footer view will be inserted into the template, not just the string HTML, so event handlers, etc from the child view will work correctly. If you only need the html content of another template (with no behaviors, etc), you can call the partial method directly from a template:</p>

<pre><code>{{{partial &quot;path/to/template&quot;}}}
</code></pre>

<p>Attributes to initialize the partial with may be passed as the second argument. Pass {render:false} as the third arguement to prevent the partially from automatically being rendered when it is initialized.</p>

<pre><code>this.partial('Footer',{key:'value'},{render: false});
</code></pre>

<p>You can also assign any view instance to a custom key name:</p>

<pre><code>this.partial('custom_key',new Phoenix.Views.Footer());

//template.handlebars
{{{custom_key}}}
</code></pre>

<h3 id="phoenix-view-render">render <em>object.render()</em></h3>

<p>By default calls this.html(this.renderTemplate(this.name + &quot;.handlebars&quot;))</p>

<h3 id="phoenix-view-rendertemplate">renderTemplate <em>object.renderTemplate(path_to_template [,attributes])</em></h3>

<p>Render a template with the given attributes, return the string output.</p>

<h3 id="phoenix-view-html">html <em>object.html([content])</em></h3>

<p>Overwrites main element of the view. Views and Mixins (such as Scrollable) may change what the main element is. Returns the element which was updated allowing for chainable calls.</p>

<pre><code>this.html('&lt;p&gt;&lt;/p&gt;').addClass('name')
</code></pre>

<h3 id="phoenix-view-serialize">serialize <em>object.serialize(callback [,options])</em></h3>

<p>Serializes the form on the page, invoking the callback with the serialized attributes. Will call <em>validate</em> and <em>model.validate</em> which in turn may trigger an <em>error</em> event. If an <em>error</em> event occurs the callback will not be invoked.</p>

<pre><code>this.serialize(function(attributes) {
  //  will only be called if there are no errors
  //  present after validate() is called
});
</code></pre>

<p>Options may contain:</p>

<ul>
<li>set - if a <em>model</em> is present set the serialized attributes via <em>model.set</em>, defaults to true</li>
<li>validate - wether or not to call <em>validate</em> and <em>model.valiate</em>, defaults to true</li>
<li>focus - if validation fails, wether or not focus the first input with an error, defaults to true</li>
</ul>

<h3 id="phoenix-view-populate">populate <em>object.populate([attributes])</em></h3>

<p>Populates a form in the view with <em>this.attributes()</em> or the passed attributes.</p>

<h3 id="phoenix-view-validate">validate <em>object.validate(attributes)</em></h3>

<p>Override in views requiring form validation. Should return nothing if form is valid, otherwise an array consisting of objects with <em>name</em> and <em>message</em> keys. <em>name</em> can be omitted if the error does not refer to a particular form field.</p>

<pre><code>validate: function(attributes) {
  var errors = [];
  if (attributes.email === '') {
    errors.push({
      name: 'email',
      message: 'Email cannot be blank.'
    });
  }
  if (errors.length) {
    return errors;
  }
}
</code></pre>

<h3 id="phoenix-view-_checkfirstradio">_checkFirstRadio <em>object._checkFirstRadio()</em></h3>

<p>Sets <em>checked=&quot;checked&quot;</em> on the first radio input in the view.</p>

<h3 id="phoenix-view-setmodel">setModel <em>object.setModel(model [,options])</em></h3>

<p>Set the <em>model</em> attribute of the view, triggering some customizable behaviors:</p>

<ul>
<li>fetch - auto fetch the model if empty, defaults to true</li>
<li>success - a callback to call when fetch() succeeds, defaults to noop</li>
<li>render - wether to call render after <em>setModel</em> and on the model's <em>change</em> event</li>
<li>populate - wether to auto call <em>populate</em>, if there is no form in the view <em>populate</em> will have no effect</li>
<li>errors - wether to bind error handlers, defaults to true</li>
<li>validate - wether to call <em>validate</em> on the model in addition to the view when <em>serialize</em> is called</li>
</ul>

<h3 id="phoenix-view-setcollection">setCollection <em>object.setCollection(collection [,options])</em></h3>

<p>Set the <em>collection</em> attribute of the view. This will bind event handlers to call <em>_renderItem</em>, <em>_renderEmpty</em> as the collection changes, and by default will call fetch() on the collection. Options may contain:</p>

<ul>
<li><strong>fetch</strong> - auto fetch, defaults to true</li>
<li><strong>sucess</strong> - a callback to call when fetch() succeeds, defaults to noop</li>
<li><strong>errors</strong> - wether to bind error handlers, defaults to true</li>
</ul>

<h3 id="phoenix-view-attributes">attributes <em>object.attributes()</em></h3>

<p>Override if needed. Called to extract attributes for <em>render</em>. Defaults to:</p>

<p>return this.model ? this.model.attributes : this;</p>

<h3 id="phoenix-view-itemattributes">itemAttributes <em>object.itemAttributes(model)</em></h3>

<p>Override if needed. Called to extract attributes for <em>_renderItem</em> from each item in a collection. Defaults to:</p>

<pre><code>returns model.attributes;
</code></pre>

<h3 id="phoenix-view-_renderitem">_renderItem <em>object._renderItem(model)</em></h3>

<p>Override if needed. Called for each item in a collection after <em>setCollection</em> is called. Must return a string, defaults to:</p>

<pre><code>return this.renderTemplate(this.name + '-item.handlebars',this.itemAttributes.call(this,item)); 
</code></pre>

<h3 id="phoenix-view-_renderempty">_renderEmpty <em>object._renderEmpty()</em></h3>

<p>Override if needed. Called when the collection is empty. Must return a string. Defaults to:</p>

<pre><code>return this.renderTemplate(this.name + '-empty.handlebars');
</code></pre>

<h3 id="phoenix-view-_collectionelement">_collectionElement <em>object._collectionElement</em></h3>

<p>Override if needed. Element or String selector to select the collection element in the view, defaults to &quot;.collection&quot;</p>

<h4>Events</h4>

<ul>
<li><strong>reflow</strong> - must be triggered by child, should be triggered whenever a reflow / repaint needs to occur, mainly used by Scrollable, may go away in the future</li>
<li><strong>load:start</strong> - triggered by card implementor, shows card specific loading indicator</li>
<li><strong>load:end</strong> - triggered by card implementor, hides card specific loading indicator</li>
<li><strong>error</strong> - triggered by <em>serialize</em> or by the bound <em>model</em> or <em>collection</em></li>
</ul>

<h2 id="phoenix-layoutview">Phoenix.layoutView</h2>

<p>A singleton instance of Phoenix.Views.Layout which controls the flow between views.</p>

<h3 id="phoenix-layoutview-getcurrentcard">getCurrentCard <em>Phoenix.layoutView.getCurrentCard()</em></h3>

<h3 id="phoenix-layoutview-setcard">setCard <em>Phoenix.layoutView.setCard(card [,params])</em></h3>

<p>Params may contain a &quot;transition&quot; key which sets the next transition mode</p>

<h3 id="phoenix-layoutview-setnexttransitionmode">setNextTransitionMode <em>Phoenix.layoutView.setNextTransitionMode(mode)</em></h3>

<h3 id="phoenix-layoutview-cardselement">cardsElement <em>Phoenix.layoutView.cardsElement</em></h3>

<p>The element in which all cards are contained.</p>

<h3 id="phoenix-layoutview-_transition">_transition <em>Phoenix.layoutView._transition</em></h3>

<p>The string to be passed to <em>-webkit-transform</em>, defaults to <em>333ms ease-in-out</em></p>

<h3 id="phoenix-layoutview-_defaulttransitionmode">_defaultTransitionMode <em>Phoenix.layoutView._defaultTransitionMode</em></h3>

<p>Defaults to <em>slideRight</em></p>

<h3 id="phoenix-layoutview-events">Events</h3>

<ul>
<li><strong>load:start</strong> - triggered by other controllers or views</li>
<li><strong>load:end</strong> - triggered by other controllers or views</li>
<li><strong>change:card</strong> (card,url) - triggered when card is ready and animations are complete</li>
</ul>

<h3 id="phoenix-layoutview-transitions">Transitions</h3>

<p>When calling <em>setCard</em> a transition will occur from the old card to the new. The type of transition can be explicitly set with Phoenix.layoutView.setNextTransitionMode() or by specifying a data-transition HTML attribute on a link, or by passing an object with a &quot;transition&quot; key as the second argument to <em>setCard</em>.</p>

<p>Transition mode may be any one of the following:</p>

<ul>
<li><strong>slideRight</strong></li>
<li><strong>slideLeft</strong></li>
<li><strong>slideUp</strong></li>
<li><strong>slideDown</strong></li>
<li><strong>none</strong></li>
</ul>

<h2 id="phoenix-views-card">Phoenix.Views.Card</h2>

<p>A base class representing a card / screen. Mixes in:</p>

<ul>
<li><a href="#loadable">Loadable</a></li>
<li><a href="#activatable">Activatable</a></li>
<li><a href="#activatable">Destroyable</a></li>
</ul>

<h3 id="phoenix-views-card-events">Events</h3>

<ul>
<li><strong>activated</strong> - called after card is attached to the DOM, before transition animation is complete</li>
<li><strong>ready</strong> - called after card is attached to DOM, and after transition animation is complete</li>
<li><strong>deactivated</strong> - called after card is removed from DOM, after transition animation is complete</li>
<li><strong>destroyed</strong> - triggered when destroy is called, should be used to perform any needed cleanup</li>
</ul>

<h2 id="activatable">Activatable</h2>

<p>Used by Phoenix.layoutView and Card views. Can be used generically as needed.</p>

<h3 id="activatable-activate">activate <em>object.activate()</em></h3>

<h3 id="activatable-deactivate">deactivate <em>object.deactivate()</em></h3>

<h3 id="activatable-events">Events</h3>

<ul>
<li><strong>activated</strong></li>
<li><strong>deactivated</strong></li>
</ul>

<h2 id="loadable">Loadable</h2>

<p>Adds and removes <em>_loadingClassName</em> to <em>this.el</em> and the page body element after <em>load:start</em> occurs and <em>_loadingTimeoutDuration</em> has elapsed. <em>load:start</em> and <em>load:end</em> events should be triggered by your application.</p>

<pre><code>this.trigger('load:start');
collection.fetch({
  success: _.bind(function(){
    this.trigger('load:end');
  },this)
});
</code></pre>

<h3 id="loadable-_loadingtimeoutduration">_loadingTimeoutDuration <em>object._loadingTimeoutDuration</em></h3>

<p>Amount of time before <em>load:timeout</em> event is triggered after <em>load:start</em> occurs.</p>

<h3 id="loadable-_loadingclassname">_loadingClassName <em>object._loadingClassName</em></h3>

<p>Defaults to &quot;loading&quot;</p>

<h2 id="orientable">Orientable</h2>

<p>Calls <em>render</em> on <em>orientationchange</em> when mixed in. Use <em>window.orientation</em> to determine current orientation in render.</p>

<h2 id="scrollable">Scrollable</h2>

<p>Make the content in your view scrollable.</p>

<h3 id="scrollable-enablescrolling">enableScrolling <em>object.enableScrolling()</em></h3>

<p>Automatically called when Scrollable is mixed in.</p>

<h3 id="scrollable-disalbescrolling">disalbeScrolling <em>object.disableScrolling()</em></h3>

<h3 id="scrollable-scrollto">scrollTo <em>object.scrollTo(y [,duration])</em></h3>

<h3 id="scrollable-detectscrolltobottom">detectScrollToBottom <em>object.detectScrollToBottom(callback)</em></h3>

<p>Detects when the user has scrolled to near the bottom of the view. <em>callback</em> recieves an function which must be invoked before <em>callback</em> will be invoked again.</p>

<pre><code>this.detectScrollToBottom(_.bind(function(next) {
  this.trigger('load:start');
  this.collection.loadMoreItems(_.bind(function() {
    this.trigger('load:end');
    next();
  }, this));
}, this));
</code></pre>

<h3 id="scrollable-_detectscrolltobottomthreshold">_detectScrollToBottomThreshold <em>Phoenix.ViewMixins.Scrollable._detectScrollToBottomThreshold</em></h3>

<p>In percent, defaults to 80.</p>

<h2 id="destroyable">Destroyable</h2>

<h3 id="destroyable-destroy">destroy <em>object.destroy()</em></h3>

<h3 id="destroyable-events">Events</h3>

<ul>
<li><strong>destroyed</strong></li>
</ul>
  </div>
</body>
<script src="http://code.jquery.com/jquery-1.5.min.js"></script></html>